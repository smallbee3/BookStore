[Ch2 Selectin Sort, 선택 정렬]


02 Array & Linked List, 배열과 연결리스트


* 원소 추가를 한다면? p.32
연결리스트 > 배열

* 리스트의 가운데에 (원소) 추가를 한다면? p.34
연결리스트 > 배열

*삭제를 한다면? p.36
연결리스트 > 배열

* 사용빈도가 많다면?
연결리스트 < 배열
( 임의의 원소에 접근하는 것이 가능하기 때문)

* 배열과 리스트에서 읽기와 쓰기, 삭제 연산을 하는데 걸리는 실행 시간  p.36
	배열	리스트
읽기	O(1)	O(n)
쓰기	O(n)	O(1)
삭제	O(n)	O(1)

* 자료에 접근하는 방식  p.36
	배열	리스트
순차 접근
(sequential access)
O
O
임의 접근
(random access)
O
X

p.36
insert할 때와 달리 삭제할 때는 실패하는 경우는 없습니다. insert할 때는 가끔 메모리에 남아있는 공간이 없어서 실패할 수도 있습니다. 하지만 원소를 지우는 것은 언제나 할 수 있죠.



03 Selection Sort, 선택 정렬

* Bg O notation
O(n²)


[TIP] 실행할 때마다 더 적은 항목 점검하기
아마도 앞의 설명에서 궁금한 점이 생겼을 수 있습니다. 이 연산을 할 때 실제로 점검해야 할 항목의 수는 줄어들고 있습니다. 최종적으로는 하나의 항목만 남죠. 그런데 왜 실행 시간은 O(n²)일까요? 아주 좋은 질문이에요. 그 대답은 빅오 표기법의 상수항과 관련이 있습니다. 자세한 설명은 4장에서 할 예정이지만 간단하게 설명해 볼게요.
...


* 2장에서 배운 내용
- 컴퓨터 메모리는 거대한 서랍장과 같습니다.
- 여러 개의 항목을 저장하고 싶을 때는 배열이나 리스트를 사용하세요.
- 배열을 쓰면 모든 항목은 이웃하는 위치에 저장됩니다.
- 리스트를 쓰면 모든 항목이 흩어지지만, 각 항목은 다음 항목의 주소를 저장하고 있습니다.
- 배열은 읽기가 빠릅니다.
- 연결 리스트는 삽입과 삭제가 빠릅니다.
- 배열의 모든 원소는 같은 자료형(예를 들면, 모두 정수형이거나 모두 실수형)이어야 합니다.

p.45
2-3
페이스북이 사용자 이름 목록을 가지고 있다고 합시다. 누군가가 페이스북에 로그인하려고 하면 사용자 이름 목록에서 이름을 검색 해야 합니다.
 ...
페이스북이 이 목록을 검색하기 위해 이진 탐색을 사용한다고 가정한다면, 이진 탐색을 하기 위해 임의 접근이 가능해야 합니다. 즉, 이름 목록 중간에 있는 값도 즉시 읽을 수 있어야 합니다.