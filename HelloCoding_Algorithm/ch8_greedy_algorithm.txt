[Ch8 Greedy algorithm]

p.194
많은 사람이 이 알고리즘이 의심스러울 만큼 너무 간단해 보인다고 말합니다. 하지만 간단하다는 것, 그것이 바로 탐욕 알고리즘(greedy algorithm)의 장점이죠! 탐욕 알고리즘은 간단합니다. 각각의 단계에서 최적의 수를 찾아내면 됩니다.

p.199
... 탐욕 알고리즘은 거의 정답과 비슷한 답을 유추합니다.

1. 아직 방송하지 않은 지역 중 가장 많은 지역에 방송할 수 있는 방송국을 고릅니다. 이미 방송되고 있는 지역이 일부 포함되어 있어도 상관없습니다. 
2. 모든 주에 방송이 될 때까지 선택을 반복합니다.


이것을 근사 알고리즘(approximation algorithm)이라고 합니다. 정확한 답을 계산하는 데 시간이 너무 많이 걸린다면 근사 알고리즘을 사용할 수 있습니다. 근사 알고리즘의 성능은 다음 두 가지로 판단합니다.

* 얼마나 빠른가
* 최적해에 얼마나 가까운가

탐욕 알고리즘은 다루기 간단할뿐더러 그 단순함으로 인해 실행속도가 빠르기 때문에 좋은 선택이 될 수 있습니다. 이 경우에 탐욕 알고리즘의 실행 속도는 O(n²) 시간입니다. 여기에서 n은 방송국의 수입니다.


p.198
* 집합 커버링 문제, set_covering problem
O(2ⁿ)

p.20, p.213
* 외판원 문제, traveling salesperson problem
O(n!)

: (둘다) NP-완전 문제, NP-complete problem



p.86 NP-완전 문제 시간 비교
집합 커버링 문제 < 외판원 문제
	O(2ⁿ)		O(n!)
100	4 x 10²¹		2.9 x 10¹⁴⁹



p.213
[TIP] 근사화
외판원 문제에 대한 좋은 근사 알고리즘은 없을까요? 짧은 거리를 찾는 간단한 방법 말입니다. 이 다음을 읽기 전에 한 번 여러분만의 답을 생각해 보세요.  -> 저 같으면 이렇게 하겠습니다.  1) 일단 아무 도시나 고릅니다.  2) 그리고 아직 방문하지 않은 가장 가까운 도시를 다음 방문지로 선택합니다.



p.215
문제가 NP-완전  문제라는 것을 알아내는 법
... 앞 장에서 이야기한 최단 경로 문제는 두 지점 간의, 즉 지점 A에서 지점 B로 가는 최단 경로를 계산하는 것이었습니다.
하지만 몇 개의 지점을 연결하는 최단 경로를 찾으려 하면 NP-완전 문제인 외판원 문제가 되어버립니다. 답부터 말하자면 여러분이 풀고 있는 문제가 NP-완전 문제인지 아닌지 알 수 있는 쉬운 방법은 존재하지 않습니다. 다만 다음과 같은 몇 가지 참고 사항은 있습니다.

* 항목이 적을 때는 알고리즘이 빠른데, 항목이 늘어나면서 갑자기 느려집니다.
* "X의 모든 조합"이라고 하면 보통 NP-완전 문제입니다.
* 더 작은 하위 문제로 변환할 수 없어서 X의 가능한 모든 버전을 계산해야 한다면 아마도 NP-완전 문제일 것입니다.
* 문제가 수열(외판원 문제와 같은 도시의 순서같이)을 포함하고 풀기가 어려우면 NP-완전 문제일 수 있습니다.
* 만약 문제에 집합(라디오 방송국 집합처럼)이 있고 풀기가 어려우면 NP-완전 문제일 수 있습니다.
* 문제를 집합 커버링 문제나 외판원 문제로 재정의할 수 있다면, 명백하게 NP-완전 문제입니다.


[8장에서 배운 내용]
- 탐욕 알고리즘은 전역 최적화를 목표로 하지만, 실제로는 국소 최적화를 합니다.
- NP-완전 문제는 빠른 해답이 알려지지 않았습니다.
- 만약 NP-완전 문제가 주어지면 근사 알고리즘을 쓰는 것이 최선입니다.
- 탐욕 알고리즘은 작성하기도 쉽고 빠르기 때문에 좋은 근사 알고리즘이 될 수 있습니다.
