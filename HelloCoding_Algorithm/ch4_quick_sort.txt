[Ch4 Quicksort, 퀵정렬]


01 Divde-and-Conquer, 분할 정복

p.69
분할 정복 전략은 재귀적 알고리즘입니다.


p.79
* pivot : 기준원소
* partitioning : 분할
* sub-array : 하위 배열


p.73
정리하자면 분할 정복 전략은 다음과 같이 동작합니다.
1. 가장 간단한 경우로 기본 단계를 찾습니다.
2. 여러분에게 주어진 문제를 작게 줄여서 기본 단계가 되도록 만드는 법을 찾아냅니다.

분할 정복 전략은 문제에 바로 적용할 수 있는 단순한 알고리즘이 아닙니다. 그보다는 문제를 풀기 위한 방법론에 가깝죠. ...

p.76
[NOTE]
배열을 포함하는 재귀 함수를 만들 때, 기본 단계는 보통 빈 배열이나 원소가 하나뿐인 배열이 됩니다. 만약 문제를 풀다 막히면 이 방법을 사용해 보세요.

p.91
여러분이 본 첫번째 예제는 최악의 경우를 나타내는 시나리오입니다. 그리고 두 번째 경우가 최선의 경우를 나타내는 시나리오죠. 최악의 경우에는 스택의 크기가 O(n)이 됩니다. 하지만 최선의 경우에는 스택의 크기가 O(log n)이 되죠.

이제 스택의 첫 번째 단계를 살펴보겠습니다. 기준 원소로 원소 하나를 선택하면 나머지 원소들은 두 개의 하위 배열로 나누어 집니다. 이렇게 나누기 위해서는 8개의 원소를 모두 기준 원소와 비교해야 합니다. 이 작업에는 O(n)의 실행 시간이 걸립니다. 사실은 호출 스택의 첫 번째 단계뿐 아니라 이후의 모든 호출 스택에서도 O(n)개의 원소를 비교해야 합니다.

...

p.93
이 예에는 O(logn) 단계가 있습니다(정확히 기술적으로 표현하자면 호출 스택의 높이는 O(logn)입니다). 그리고 각각의 단계는 O(n) 시간이 걸립니다. 따라서 전체 알고리즘은 O(n) x O(logn) = O(n logn) 시간이 걸립니다. 이것이 최선의 경우입니다.
최악의 경우에는 O(n)개의 단계가 있으므로 전체 알고리즘은 O(n) x O(n) = O(n²) 시간이 걸립니다.

그런데 퀵 정렬에서는 일반적인 경우에도 최선의 경우와 같은 실행 속도를 가집니다. 만약 기준 원소를 전체 배열에서 무작위로 선택한다면 퀵 정렬은 평균적으로 O(nlogn)실행 시간을 가지죠.



* 4장에서 배운 내용
- 분할 정복은 문제를 더 작은 조각으로 나누어 풉니다. 만약 리스트에 분할 정복을 적용한다면 기본 단계는 원소가 없는 빈 배열이거나 하나의 원소만 가진 배열이 됩니다.
- 퀵 정렬을 구현하려면 기준 원소를 무작위로 선택합니다. 퀵 정렬의 평균적인 실행 시간은 O(nlogn)입니다!
- 빅오 표기법에서 가끔씩 상수가 중요해질 때도 있습니다. 퀵 정렬이 병합 정렬보다 빠른 이유도 상수 때문입니다.
- 단순 탐색과 이진 탐색을 비교할 때는 상수항이 전혀 문제가 되지 않습니다. 왜냐하면 리스트가 길어지면 O(logn)이 O(n)보다 훨씬 빨라지니까요.
