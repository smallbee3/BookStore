[Lesson8 Selection Sort Algorithm]

p.93
8.2 선택 정렬 알고리즘의 분석

그러나 데이터를 정렬되지 않은 부분에서 정렬된 쪽으로 이동하는 횟수는 (N-1)회이다. 그 이유는 일단 정렬되지 않은 부분에서 가장 작은 값을 갖는 데이터를 찾은 후에 데이터를 교환하기 때문이다.
...
이와 같은 선택 정렬 알고리즘의 장점은 정렬할 데이터 하나하나의 크기가 큰 경우에 유용하다. 비교 횟수는 (N²/2)회나 되기 때문에 큰 편이지만 데이터 교환 횟수는 (N-1)회이면 충분하게 된다. 따라서 교환 횟수가 상대적으로 적기 때문에 정렬할 데이터의 크기가 큰 경우라면 다른 정렬 알고리즘보다 유용하다고 볼 수 있다.



8.3 삽입 정렬 알고리즘 (Insert Sort Algorithm)

선택 정렬 알고리즘이 정렬되지 않은 데이터 중에 가장 작은 값을 찾아서 정렬을 하는 방식이라면 삽입 정렬은 그러한 작은 값을 찾는 검색 과정이 필요 없는 정렬 알고리즘이다. 오히려 순차적으로 정렬하면서 현재의 값을 정렬되어 있는 값들과 비교하여 위치로 삽입하는 방식이다.




181106 Selection Sort의  비교 연산이 N*(N-1)/2 회인 이유

p.93
1) 아래 코드에서 보면 바깥 for문에서 일단 i가 0 ~ n-2 까지 할당되므로, 총 n-1회 진행된다.

```
def selected_sort(list):
	for i in range(len(list)-1):
		...

		for j in range( i+1, len(list)):
			...
```

2) 그리고 안쪽 for문에서 위에서 전달된 i는

i	0		1		2		...	n-1		n-2      -> n-1회
j	1~n-1	2~n-1	3~n-1      ...	n-2~n-1	n-1~n-1
ct	n-1회	n-2회	n-3 회	...	2회		1회 (count)


(n - 1) + (n - 2) + ... +2 + 1 = n(n - 1)/2 = O(n2)
https://www.sparknotes.com/cs/sorting/select/section1/



181106 (위 표를 통한 책 속 내용 이해)
p.93
8.2 선택 정렬 알고리즘의 분석

그러나 데이터를 정렬되지 않은 부분에서 정렬된 쪽으로 이동하는 횟수는 (N-1)회이다. 그 이유는 일단 정렬되지 않은 부분에서 가장 작은 값을 갖는 데이터를 찾은 후에 데이터를 교환하기 때문이다.
...
이와 같은 선택 정렬 알고리즘의 장점은 정렬할 데이터 하나하나의 크기가 큰 경우에 유용하다. 비교 횟수는 (N²/2)회나 되기 때문에 큰 편이지만 데이터 교환 횟수는 (N-1)회이면 충분하게 된다. 따라서 교환 횟수가 상대적으로 적기 때문에 정렬할 데이터의 크기가 큰 경우라면 다른 정렬 알고리즘보다 유용하다고 볼 수 있다.
