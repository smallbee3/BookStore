[SQL더쉽게] Ch5 복잡한 쿼리

[5-1  뷰]

학습 포인트
* SQL 관점에서 보면 뷰는 '테이블과 동일'한 것이다. 둘의 차이점은 테이블 안에는 실제 데이터가 저장되고 뷰 안에는 'SELECT 문'이 저장된다는 것이다 (뷰 자체는 데이터를 가지지 않는다) 
* 뷰를 사용하면, 필요한 데이터가 복수의 테이블에 저장돼 있어서 집약 시 처리가 복잡해지는 경우 등에도 쉽게 이를 구현할 수 있다. 
* 자주 사용하는 SELECT 문을 뷰로 만들어서 반복적으로 사용할 수 있다. 
* 뷰에는  1. 'ORDER BY 구는 사용할 수 없다.'  2. '뷰에 대한 갱신처리는 불가능하다' 위 두 가지 제약사항이 존재한다



p.155
뷰와 테이블
뷰란 한마디로 설명하자면, SQL 관점에서 볼 때 '테이블과 동일한 것'이다. 실제로 SQL문 안에서는 테이블인지 뷰인지를 의식할 필요가 거의 없다.
... 적어도 SELECT 문을 구성할 때에는 테이블과 뷰의 차이를 고려하지 않아도 된다.



p.155
그렇다면 뷰와 테이블의 차이는 무엇일까? 그것은 단 한가지인데, '실제 데이터를 저장하고 있는지 여부'다.

보통 테이블을 만들어서 INSERT 문으로 데이터를 추가하면 데이터베이스에 데이터를 저장할 수 있다. 그리고 이 데이터베이스에 데이터가 실제로 저장되는 위치는 컴퓨터 내의 기억 장치(일반적으론 하드 디스크)다. 따라서 SELECT 문으로 데이터를 검색할 때는 실제로 기억 장치(하드 디스크)에서 데이터를 끌어와서 다양한 계산을 한 뒤 사용자에게 결과를 반환하는 과정을 거친다.

반면, 뷰는 데이터를 기억 장치에 저장하지 않는다. 그러면 어디에 데이터를 저장하는 것일까? 정답은 '어디에도 저장하지 않는다'다. 뷰가 저장하는 것은 'SELECT 문' 자체다(그림 5-1). 뷰에서 데이터를 꺼내려고 할 때 뷰는 내부적으로 SELECT 문을 실행해서 일시적인 가상 테이블을 만든다.



p.156
ㅁ 뷰가 가진 이점

1 ) 기억 장치의 용량 절약
첫 번째는 데이터를 저장하지 않기 때문에 기억 장치 용량을 절약할 수 있다. 예를 들어, 4장의 4-1절에서 상품분류(goods_classfiy)별로 집약한 테이블을 만들었다. 이 테이블에 포함된 데이터도 결국 기억 장치에 저장되기 때문에 그만큼의 데이터 영역을 소비한다. 하지만 이와 동일한 데이터를 뷰로 저장하면 리스트 5-1처럼 SELECT 문만 저장하면 되기 때문에 기억 장치의 데이터 영역을 절약할 수 있다.
...
실제 업무에서는 데이터양이 크기 때문에 뷰를 통한 데이터 절약 효과도 매우 크다.

p.157
[ ! ] 5-1
테이블이 '실제 데이터'를 저장하는 반면, 뷰는 테이블에서 데이터를 꺼내는 'SELECT 문'을 저장한다.


2 ) SELECT 문을 저장해서 반복 사용
두 번째 이점은 자주 사용하는 SELECT 문을 매번 작성하지 않고 뷰로 저장해 반복해서 사용할 수 있다는 것이다. 한번 뷰를 만들어 두고 이후에는 그것을 호출해서 SELECT 문 결과를 간단히 얻을 수 있다. 집계나 조건이 복잡하고 SELECT 문의 몸집이 커지면 커질수록 뷰를 통해 얻을 수 있는 편의성이 커진다.


3 ) 최신 상태의 데이터 선택
게다가, 뷰가 포함하는 데이터는 원 테이블과 연동해서 자동으로 최신 상태를 유지한다. 뷰란, 결국 'SELECT 문'이기 때문에 '뷰를 참조한다'란 것은 '해당 SELECT 문을 실행한다'는 의미다. 그래서 최신 상태의 데이터를 선택할 수 있는 것이다. 이것은 데이터를 테이블에 저장한 경우에는 얻을 수 없는 이점이다.

[주 5-1]
(뷰가 아니라) 데이터를 테이블로 가지고 있는 경우, 해당 테이블을 명시적으로 갱신하는 SQL을 실행하지 않으면 데이터가 갱신되지 않는다.



p.157
뷰 작성 방법
뷰를 작성하려면 CREATE VIEW 문을 사용한다.

구문 5-1
```
CREATE VIEW 뷰명 (<뷰의 열명1>, <뷰의 열명2>, ⋅⋅⋅)
AS
<SELECT 문>
```

e.g.
CREATE VIEW GoodsSum
AS
SELECT goods_classify, COUNT(*)
  FROM Goods
 GROUP BY goods_classify;

==

CREATE VIEW GoodsSum (goods_classify, cnt_goods)
AS
SELECT goods_classify, COUNT(*)
  FROM Goods
 GROUP BY goods_classify;

==

CREATE VIEW GoodsSum (abc, def)
AS
SELECT goods_classify, COUNT(*)
  FROM Goods
 GROUP BY goods_classify;



p.158
...
두 번째 행의 AS 키워드 'AS'는 절대 생략해서는 안 된다. 이 AS는 열명이나 테이블명에 별명을 부여할 때 사용했던 AS와는 달라서 생략하면 에러로 처리된다.

뷰 사용 방법은 테이블과 동일하며, SELECT 문의 FROM 구에 쓸 수 있다.

```
SELECT goods_classify, cnt_goods
  FROM GoodsSum;
```

...
뷰 정의에는 어떤 SELECT 문이든 기술할 수 있다. WHERE, GROUP BY, HAVING도 사용할 수 있으며, 'SELECT *'를 사용해서 모든 열을 지정할 수도 있다.


ㅁ 뷰 검색
뷰를 FROM 구에 지정했을 때 검색은 다음 2단계를 거친다.

1 ) 먼저, 뷰에 정의된 SELECT 문이 실행되고,
2 ) 그 결과에 대해 뷰를 FROM 구에 지정한 SELECT 문이 실행된다.

즉, 뷰 검색에서는 항상 두 개 이상의 SELECT 문이 실행되는 것이다. 여기서 '두 개'가 아닌 '두 개 이상'이라고 표현한 이유는, 뷰를 가지고 또 다른 뷰를 만드는  '지붕 위에 지붕'과 같은 형태(일명 '다단 뷰')도 가능하기 때문이다. 예를 들어 GoodsSum 뷰를 가지고 리스트 5-4와 같은 뷰 정의를 통해 GoodsSumJimi 뷰를 만들 수 있다.

리스트 5-4
CREATE VIEW GoodsSumJim (goods_classify, cnt_goods)
AS
SELECT goods_classify, cnt_goods
  FROM GoodsSum
 WHERE goods_classify = '사무용품';


뷰 위에 뷰를 겹치는 것은 구문상 문제는 없지만 가능한 사용을 피하도록 한다. 왜냐하면 대부분의 DBMS에서는 뷰를 겹쳐 사용하게 되면 성능 저하가 일어나기 때문이다. 특히, 뷰가 익숙하지 않은 시기에는 가능한 1단 뷰를 사용하도록 하자.

p.161
[ ! ] 5-3
(가능한) 뷰 위에 뷰를 겹쳐서 사용하지 않는다.


p.161
뷰 제약사항

1 ) 뷰 정의에 ORDER BY 구는 사용할 수 없다
...
왜 ORDER BY 구를 사용할 수 없는 것일까? 테이블과 동일하게 뷰에서도 '행에는 순서가 없다'고 정하고 있기 때문이다. 실제로는 이런 ORDER BY 구를 사용한 뷰 정의문을 인정하는 DBMS도 있지만, 일반적으로 통용되는 구문은 아니다. 이 때문에 뷰 정의에서는 ORDER BY 구를 사용하지 않도록 한다.


[주 5-3]
PostgreSQL에서는 ORDER BY 구를 뷰 정의에 사용할 수 있다.


2 ) 뷰 갱신
앞에서 SELECT 문 안에서는 뷰를 테이블과 동일하게 다룰 수 있다고 했다. 그렇다면 INSERT, DELETE, UPDATE 같은 갱신형 SQL(데이터를 갱신하는 SQL)은 어떨까?

매우 엄격한 제약이 있긴 하지만 뷰 갱신이 가능한 경우가 있다. 표준 SQL에서는 다음과 같이 규정하고 있다.

'뷰 정의 SELECT 문이 몇 가지 조건을 만족하는 경우 뷰 갱신이 가능하다'
1. SELECT 구에 DISTINCT가 포함되어 있지 않다
2. FROM 구에 포함되는 테이블이 하나다
3. GROUP BY 구를 사용하고 있지 않다
4. HAVING 구를 사용하고 있지 않다

조건들 대부분은 집약에 관련된 것들이다. 쉽게 말하면, 샘플로 사용한 GoodsSum처럼 뷰가 원 테이블을 집약한 결괄르 보존하고 있는 경우, 뷰에서 발생한 변경을 원 테이블에 어떻게 반영하면 좋을지 판단할 수 없다.
예를 들어, GoodsSum 뷰에 다음과 같은 INSERT 문을 실행했다고 하자.

```
INSERT INTO GoodsSum VALUES ('전자제품', 5);
```

하지만 이 INSERT 문은 에러로 처리된다. GoodsSum 뷰는 GROUP BY 구를 사용해서 원 테이블을 집약하고 있기 때문이다. 왜 집약한 뷰는 갱신할 수 없는 것일까?
뷰는 어디까지나 테이블로부터 파생된 것이다. 그래서 기준이 되는 테이블이 갱시되면 뷰의 데이터 내용도 변경된다. 반대로, 뷰가 갱신됐는데 테이블이 그에 맞추어 변경되지 않으면 양쪽의 정합성에 문제가 발생하게 된다.


p.164
[ ! ] 5-5
뷰와 테이블 갱신은 연동해서 이루어진다. 따라서 집약된 뷰는 갱신 불가능



p.164
ㅁ 뷰를 갱신할 수 있는 경우
반대로 말하면, 리스트 5-5처럼 집약이 없는 뷰는 갱신 가능하다.
...
물론, UPDATE 문이나 DELETE 문도 일반적인 테이블 처리 시와 동일한 방식으로 실행 가능하다. 단, 기본 테이블에 걸려 있는 다양한 제약(주 키 제약이나 NOT NULL 등)도 파생되기 때문에 주의가 필요하다.


리스트 5-5
CREATE VIEW GoodsJim (goods_id, goods_name, goods_classify, sell_price, buy_price, register_date)
AS
SELECT *
  FROM Goods
 WHERE goods_classify = '사무용품';

리스트 5-6
INSERT INTO GoodsJim VALUES ('0009', '도장', '사무용품', 95, 10, '2009-11-30');


p.164
[주의]
PostgreSQL에서는 뷰 초기 설정이 읽기 전용으로 되어 있기 때문에 리스트 5-6의 INSERT 문을 실행하면 다음과 같은 에러가 발생한다.

그래서 INSERT 문을 실행하기 전에 리스트 5-A 명령을 사용해서 뷰 갱신을 허가할 필요가 있다.
 ```
CREATE OR REPLACE RULE insert_rule
AS ON INSERT
TO  GoodsJim DO INSTEAD
INSERT INTO Goods VALUES (
           new.goods_id,
           new.goods_name,
           new.goods_classify,
           new.sell_price,
           new.buy_price,
           new.register_date);
```


뷰 삭제

뷰를 삭제하려면 DROP VIEW 문을 사용한다.

```
DROP VIEW 뷰명 (<뷰의 열명1>, <뷰의 열명2>, ⋅⋅⋅ )


p.166
[개별 구문]
PostgreSQL에서는 다단 뷰의 작성 기반이 되는 뷰를 삭제하는 경우, 그것에 의존하는 뷰가 존재하면 다음과 같은 에러가 발생한다.

이때는 의존하는 뷰 단위로 삭제하는 CASCADE 옵션을 사용해서 실행한다.
DROP VIEW GoodsSum CASCADE



p.168
[5-2  서브쿼리]

학습 포인트
* 서브 쿼리란, 한마디로 정리하면 '일회용 뷰(SELECT 문)다.' 뷰와 달리 SELECT 문 실행 종료 후에 제거된다.
* 서브쿼리에는 명칭을 붙여야 하기 때문에 처리 내용에 따라 적합한 명칭을 부여하도록 한다.
* 스칼라 서브쿼리란, '반드시 1행 1열만 결과로 반환한다'는 제약이 붙은 서브쿼리다.


서브쿼리와 뷰
이번 절에서 배우는 '서브쿼리'는 이 뷰를 기반으로 하는 기술이다. 서브쿼리의 특징을 한마디로 정리하면 '일회용 뷰'다.
뷰란 데이터 자체를 저장하는 것이 아니라 데이터를 추출하는 SELECT 문을 저장하는 방법으로, 사용자 편이성을 향상시키는 도구다. 반면, 서브쿼리는 뷰 정의 SELECT 문을 그대로 FROM 구에 삽입한 것이다.
이 SELECT 문은 내포 구조로 되어 있어서 FROM 구 안의 SELECT 문이 먼저 실행되고 그 뒤에 바깥쪽 SELECT 문이 실행된다

e.g.
리스트 5-8
CREATE VIEW GoodsSum (goods_classify, cnt_goods)
AS
SELECT goods_classify, COUNT(*)
  FROM Goods
 GROUP BY goods_classify;

SELECT goods_classify, cnt_goods
  FROM GoodsSum;


리스트 5-9
SELECT goods_classify, cnt_goods
  FROM (SELECT goods_classify, COUNT(*) AS cnt_goods
          FROM Goods
         GROUP BY goods_classify) AS GoodsSum;


[개별 구문]
Oracle에서는 FROM 구에 AS를 사용할 수 없다. 이 때문에 Oracle에서 리스트 5-9를 실행하려면 (1) 부분의 "AS GoodsSum;"을 "GoodsSum;"으로 변경하도록 한다.


ㅁ 서브쿼리 계층 수를 늘린다
서브쿼리 계층 수에 대한 제한이 원칙적으로 없기 때문에 서브쿼리 안의 FROM 구에 또 하나의 서브쿼리를 사용하고 그 안에 있는 FROM 구에 또 서브쿼리를 사용할 수 있다.
...
단, 서브쿼리 계층이 깊어질수록  SQL 문을 이해하기 어려워질 뿐만 아니라, 뷰에서 설명한 것처럼 성능에도 악영향을 끼친다. 이 때문에 계층을 너무 깊게 만들지 않는 것이 좋다.


ㅁ 서브쿼리 이름
서브쿼리의 이름은 원칙상 필요한 것으로, 처리 내용을 표현할 수 있는 적절한 이름을 부여하는 것이 좋다.



스칼라 서브쿼리
ㅁ 스칼라란?
스칼라란 '단일'이란 의미로 데이터베이스 이외 분야에도 자주 사용되는 용어다.
앞 절에서 배운 서브쿼리는 기본적으로 복수 행을 결과로 반환한다(가끔 1행만 반환하는 경우도 있다) 구조적으로는 테이블과 동일하기 때문에 당연한 결과 일 수 있다.
이에 반해 스칼라 서브쿼리는 '반드시 1행 1열만을 반환 값으로 반환한다'라는 제약을 가진 서브쿼리다. 테이블의 어떤 1행에 있는 어떤 1열의 값이란, '10'이나 '서울'처럼 하나의 값을 의미한다.

결과 값이 단일 값이란 것은 스칼라 서브쿼리의 결과 값을 =, <>등 스칼라 값을 비교 연산자의 입력 값으로 사용할 수 있다는 뜻이다. 스칼라 서브쿼리가 재미있는 것은 바로 이 때문이다. 그러면 바로 스칼라 서브쿼리를 사용해 보자.

ㅁ WHERE 구에 스칼라 서브쿼리를 사용한다
4장 4-2절에서 Goods(상품) 테이블에 다양한 조건을 사용해서 검색하는 방법을 배웠다. 그때 다음과 같은 조건으로 검색하고 싶다고 생각한 사람도 있을 것이다.

'판매단가가 전체 평균 판매단가보다 높은 상품만을 검색한다.'

가격이 상위 50%인 상품을 보고 싶은 경우 등도 이 조건으로 검색하게 된다. 하지만 이것은 일반적인 방법으로 해결할 수 없다. AVG 함수를 사용해 다음과 같은 SQL문을 작성했다고 해도 에러 처리된다.

e.g.
SELECT goods_id, goods_name, sell_price
  FROM Goods
 WHERE sell_price > AVG(sell_price);

>>
리스트 5-12
SELECT goods_id, goods_name, sell_price
  FROM Goods
 WHERE sell_price > (SELECT AVG(sell_price)
                         FROM Goods);



스칼라 서브쿼리를 쓸 수 있는 곳

스칼라 서브쿼리를 쓸 수 있는 곳은 WHERE 구만 있는 것이 아니다. 기본적으로 스칼라 값을 사용할 수 있는 곳이라면 어디든지 가능한다. 즉, 상수나 열명을 쓸 수 있는 곳이라면 모두 가능하며, SELECT 구, GROUP BY 구, HAVING  구, ORDER BY 구 등 거의 모든 곳에 쓸 수 있다.
예를 들어, SELECT 구에 앞서 사용한 평균값을 구하는 스칼라 서브쿼리를 사용하면 리스트 5-13과 같이 된다.


리스트 5-13
```
SELECT goods_id,
       goods_name,
       sell_price,
       (SELECT AVG(sell_price)
          FROM Goods) AS avg_price
  FROM Goods;
```


...
또한, HAVING 구에 사용하려면, 리스트 5-14와 같은 SELECT 문을 생각할 수 있다.
이 쿼리는 '상품분류(goods_classify)별로 게산한 평균 판매단가가 상품 전체 평균 판매단가보다 높은 상품분류를 선택'한다는 의미다.

리스트 5-14
```
SELECT goods_classify, AVG(sell_price)
  FROM Goods
 GROUP BY goods_classify
HAVING AVG(sell_price) > (SELECT AVG(sell_price)
                              FROM Goods);
```


스칼라 서브쿼리 사용 시 주의점

스칼라 서브쿼리 사용 시 주의해야 할 사항이 있는데, 그것은 '절대로 서브쿼리가 복수 행을 반환하지 않도록 해야 한다'는 것이다. 서브쿼리가 복수 행을 반환하는 시점에 이미 스칼라 서브쿼리가 아닌 일반 서브쿼리가 되어 버린다. 즉, =나 <> 같은 스칼라 값을 입력 값으로 하는 연산자를 사용할 수 없고 SELECT 구 등에도 쓸 수 없게 된다.

e.g.
```
SELECT goods_id,
       goods_name,
       sell_price,
       (SELECT AVG(sell_price)
          FROM Goods
	  GROUP BY goods_classify) AS avg_price
  FROM Goods;
```

에러가 발생하는 이유는 이 서브쿼리가 다음과 같이 복수 행을 반환하기 때문이다.

	avg
--------------
2500.0000000
 300.0000000
2795.0000000

SELECT 구 1행 안에 3행을 삽입하는 것은 불가능하다. 이 때문에 위 SELECT 문은 '서브쿼리가 복수 행을 반환하기 때문에 실행할 수 없다'는 이유로 에러가 반환된다.


[주 5-5]
예를 들어, PostgreSQL인 경우는 다음 에러가 반환된다.
'ERROR: more than one row returned by a subquery used as an expression'


p.178
[5-3  상관  서브쿼리]

학습 포인트
* 상관 서브쿼리는 작은 그룹 내에서 비교가 필요할 때 사용된다.
* GROUP BY 구와 동일하게 상관 서브쿼리도 집합을 '자르는' 기능을 가지고 있다.
* 상관 서브쿼리 결합 조건은 서브쿼리 내에서 작성하지 않으면 에러 처리되기 때문에 주의가 필요하다.


일반 서브쿼리와 상관 서브쿼리의 차이점

'상품 분류(goods_classify)별로 평균 판매단가보다 높은 상품'을 상품분류 그룹으로부터 추출하는 조건을 생각해 보자.

ㅁ 상품분류별로 평균 판매단가를 비교한다
...
상품 전체가 아닌 그룹별로 '작은 단위'로 나는 후에 해당 그룹 안의 평균 금액과 각 상품의 판매단가를 비교하고 싶은 것이다.

상품 분류별로 평균 단가를 구하는 것 자체는 어렵지 않다.

리스트 5-15
```
SELECT AVG(sell_price)
  FROM Goods
 GROUP BY goods_classify;
```

하지만 앞 절에서 배운 스칼라 서브쿼리처럼 이 SELECT 문을 그대로 서브쿼리로 WHERE 구에 작성하면 에러가 발생한다. 에러가 발생하는 이유는 앞 절에서 언급한 것처럼 이 서브쿼리가 3행 값을 반환하기 때문에 더 이상 스칼라 서브쿼리로서 역할을 하지 못하기 때문이다. WHERE 구에서 서브쿼리를 사용하는 경우에는 반드시 결과가 1행이어야 한다. 하지만 상품분류라는 그룹 단위로 판매단가와 평균단가를 비교하려면 이 방법 외에는 구현할 방법이 없어 보인다. 도대체 어떻게 하면 되는 것일까?

ㅁ 상관 서브쿼리를 사용한 해결방법
여기서 등장하는 강력한 도구가 상관 서브쿼리다. 앞서 사용한 SELECT문에 1행만 추가하면 사무용품, 의류, 주방용품, 이렇게 세 가지 분류에 대해 각 분류별 평균 판매단가보다 높게 팔리고 있는 상품을 선택할 수 있다.

리스트 5-16
```
SELECT goods_classify, goods_name, sell_price
  FROM Goods AS S1
 WHERE sell_price > (SELECT AVG(sell_price)
                         FROM Goods AS S2
                        WHERE S1.goods_classify = S2.goods_classify
                        GROUP BY goods_classify);
```

핵심 포인트는 서브쿼리 내에 추가한 WHERE 구 조건이다. 이 조건을 우리말로 표현하면, '각 상품의 판매단가와 평균 단가 비교를 같은 상품분류 내에서 한다'가 된다.

상관 서브쿼리의 경우 테이블 별명을 열명 앞에 '<테이블명>.<열명>' 형식으로 기술해 줄 필요가 있다. 비교 대상 테이블이 Goods라는 동일 테이블이기 때문에 구별을 위해서 S1, S2를 별명으로 사용했다.

이와 같이 상관 서브쿼리는 테이블 전체가 아닌, 테이블 일부 레코드 집합에 한정된 비교를 하고 싶은 경우에 사용한다. 따라서 상관 서브쿼리를 사용할 때 '묶다(바인딩한다)' 또는 '제한한다'등으로 표현하기도 한다. 이번 예의 경우 '상품분류로 묶어서' 평균 단가와 비교하고 있다.

p.181
[ ! ] 5-8
상관 서브쿼리는 작은 그룹으로 나누어 비교할 때 사용한다.


상관 서브쿼리도 결국 집합을 나누고 있다.

조금 관점을 바꿔 보면, 상관 서브쿼리도 GROUP BY와 마찬가지로 집합을 '나누는' 기능을 가지고 있다는 것을 알 수 있다. GROUP BY 구 동작을 이해하기 위해서 사용한 그림(그림 5-6)을 다시 보자.
...
상관 서브쿼리가 실행될 때 DBMS 내부 동작은 그림 5-8과 같다.

그림 5-8
SELECT 의류,		티셔츠,	1000 FROM Goods WHERE 1000 > 2500;
SELECT 의류,		와이셔츠,	4000 FROM Goods WHERE 4000 > 2500;
----------------------------------------------------------------------- SELECT 주방용품,	식칼,		3000 FROM Goods WHERE 3000 > 2795;
SELECT 주방용품,	압력솥,	6800 FROM Goods WHERE 6800 > 2795;
SELECT 주방용품,	포크,		500   FROM Goods WHERE 500 > 2795; SELECT 주방용품,	도마,		880   FROM Goods WHERE 880 > 2795;
-----------------------------------------------------------------------
SELECT 사무용품,	볼펜,		100   FROM Goods WHERE 100 > 300;
SELECT 사무용품,	펀칭기,	500   FROM Goods WHERE 500 > 300;

...
상품분류가 바뀌면 비교할 평균 단가도 바뀐다. 이와 같이 해서 각 상품의 판매단가와 평균단가가 비교되는 것이다. 상관 서브쿼리는 내부 동작이 잘 파악되지 않아서 초보자들이 이해하기 어려운 기능으로 유명하지만, 이런 내부 동작을 '도식화'해서 따라가면 이외로 간단하다는 것을 알 수 있다.


결합 조건은 반드시 서브쿼리 안에 기술

여기서 SQL 초보자가 상관 서브쿼리를 사용할 때 자주 하는 실수 한 가지를 소개하도록 한다. 그것은 '묶기' 위한 결합 조건을 서브쿼리 내부가 아닌 외부에 기술해 버리는 것이다.

```
SELECT goods_classify, goods_name, sell_price
  FROM Goods AS
 WHERE S1.goods_classify = S2.goods_classify
 AND sell_price > (SELECT AVG(sell_price)
                         FROM Goods AS S2
                        GROUP BY goods_classify);
```

이 SELECT 문은 에러 처리돼서 실행되지 않는다. 이런 작성법이 용인될 법도 하지만 SQL 규칙에서는 금지하고 있다.
그러면 어떤 규칙이 이것을 금지하고 있는 것일까? 그것은 상관명 스코프다. 의미는 간단하다. 상관명이라는 것은 S1, S2 등 테이블 별명으로 부여한 이름이다. 그리고 스코프(scope)란, 생존 범위(유효범위)를 말한다. 즉, 상관명이 통용될 수 있는 범위에 제한이 있다는 것이다.
서브 쿼리 내부에서 부여된 상관명은 해당 서브쿼리 내에서만 사용할 수 있다는 것이다. 다른 말로 하면 '안에서 밖은 볼 수 있어도 밖에서 안은 보이지 않는다'라고 할 수 있다.'
...
앞 절에서 설명한 것처럼 SQL은 안쪽 서브쿼리부터 바깥쪽 서브쿼리 순으로 실행된다. 결국, 서브쿼리 실행이 끝난 후에는 실행 결과만 남고 추출 대상이었던 테이블 S2는 사라져 버린다. 이 때문에 서브쿼리 바깥쪽이 실행되는 시점에서는 이미 S2가 존재하지 않아서 '그런 이름의 테이블은 존재하지 않습니다.'라는 에러 메시지가 반환되는 것이다.



