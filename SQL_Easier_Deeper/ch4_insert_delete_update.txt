[SQL더쉽게]  Ch4 데이터갱신


[4-1 INSERT]

p.122
[COLUMN]
복수 행 INSERT, multi row INSERT

* 첫 번째 주의점은 INSERT 문 작성 내용에 실수가 있거나 부정확한 데이터를 삽입하려고 한 경우다. 당연히 이때는 INSERT가 에러 처리되지만, 복수 행 INSERT의 경우 어느 행, 어느 지점에서 에러가 발생하고 있는지 찾아내기가 어렵다.
* DB2, SQL Server, PostgreSQL, MySQL에서는 사용할 수 있지만, Oracle에서는 사용할 수 없다.

e.g.
INSERT INTO GoodsIns VALUES ('0002', '펀칭기', '사무용품', 500, 320, '2009-09-11')
INSERT INTO GoodsIns VALUES ('0003', '와이셔츠', '의류', 4000, 2800, NULL),
INSERT INTO GoodsIns VALUES ('0004', '식칼', '주방용품', 3000, 2800, '2009-09-20');
>>
INSERT INTO GoodsIns VALUES ('0002', '펀칭기', '사무용품', 500, 320, '2009-09-11')
                             ('0003', '와이셔츠', '의류', 4000, 2800, NULL),
                            ('0004', '식칼', '주방용품', 3000, 2800, '2009-09-20');



p.124
* 기본값을 삽입한다

1 ) 명시적으로 기본값을 삽입한다
VALUE 구에 DEFAULT 키워드를 지정한다.
e.g.
INSERT INTO GoodsIns (goods_id, goods_name, goods_classify, sell_price, buy_price, register_date) VALUES ('0007', '도마', '주방용품', DEFAULT, 790, '2009-04-28');

2 ) 암묵적으로 기본값을 삽입한다
간단히 기본값이 설정되어 있는 열을 column 리스트 및 VALUE 구에서 생략하기만 하면 된다.

'명시적 작성법'을 추천한다. 왜냐하면 sell_price에 기본값이 사용되고 있다는 것을 소스를 보고 바로 알 수 있는, 알기 쉬운 SQL문이 되기 때문이다.


p.126
참고로 열명 생략에 대해 추가적으로 얘기하자면, 기본값이 설정되어 있지 않은 열을 생략한 경우는 NULL이 할당된다.
(NOT NULL 제약이 있는 열을 생략하면 INSERT 문이 에러 처리가 된다.)

181120
NULL값 할당 시 입력 대상 열 명시
위에서 생략한 열에 NULL을 할당하기 위해서는 데이터를 입력하고자 하는 대상 테이블 네임 뒤에 리스트 형식으로 대상 열을 작성해야 한다.
만약 작성하지 않으면 열의 순서대로 데이터가 입력되어 원하지 않은 결과를 얻게 된다. (가장 마지막 열에 NULL값이 입력된다.)


[ ! ] 4-2
INSERT 문에서 열명을 생략하면 기본값이 할당된다.
(기본값이 설정되어 있지 않으면 NULL이 된다)


p.127
* 다른 테이블에서 데이터를 복사한다
데이터를 삽입하는 방법으로는 VALUE 구를 사용해서 구체적인 데이터를 지정하는 방법 이외에도 '다른 테이블에서 선택'하는 방법이 있다.

(1)
INSERT INTO GoodsCopy (goods_id, goods_name, goods_classify, sell_price, buy_price, register_date)
SELECT goods_id, goods_name, goods_classification, sell_price, buy_price, register_date
  FROM Goods;
>> INSERT 0 8

(2)
INSERT INTO GoodsCopy
SELECT goods_id, goods_name, goods_classification, sell_price, buy_price, register_date
  FROM Goods;
>> INSERT 0 8



p.129
[ ! ] 4-3
INSERT 문 내의 SELECT 문에서는 WHERE 구나 GROUP BY 구 등 어떤 SQL 구문도 사용할 수 있다
(단,ORDER BY 구는 사용해도 효과가 없다.)



p.130
[4-2  DELETE] 
학습 포인트
* 일부 행만 삭제하려면 WHERE 구에 대상 행의 조건을 지정한다. WHERE 구로 삭제 대상을제한한 DELETE 문을 탐색형 DELETE 라고 한다.


p.131
[주 4-7]
INSERT 문과 마찬가지로 데이터 갱신 처리는 모든 레코드를 기본 단위로 처리한다. 이것은 다음절에서 배울 UPDATE 문도 마찬가지다.


p.131
[ ! ] 4-4
DELETE 문의 삭제 대상은 테이블이나 열이 아닌 '레코드(행)'다.

e.g.
DELETE <테이블명> (X)
>> 삭제 대상이 테이블이 아니고 테이블에 포함된 '행(레코드)'이기 때문

DELETE <열명> FROM <테이블명> (X)
>> DELETE 문의 삭제 대상은 열이 아닌 행이기 때문에 DELETE 문으로 일부 열만 삭제하는 것은 불가능하다. 당연한 얘기지만, 별표를 사용해서 "DELETE * FROM Goods;"라고 쓰는 것도 잘못된 방법이다.



p.133
GROUP BY, HAVING, ORDER BY (X)
참고로, SELECT 문과 달리 DELETE 문은 GROUP BY, HAVING, ORDER BY 구를 지정할 수 없다. 사용할 수 있는 것은 WHERE 구뿐이다.
이유는 조금만 생각해 보면 알 수 있다. GROUP BY와 HAVING은 원 테이블에서 데이터를 선택할 때 '추출 형식을 바꾸고 싶은' 경우에 사용한다. ORDER BY도 결과의 표시 순서를 지정하는 것이 목적이다. 이 때문에 테이블 데이터 자체를 삭제하는 처리에는 필요가 없는 구문들이다.


p.134
[COLUMN]
삭제와 버리기
테이블에서 데이터를 삭제하기 위한 방법으로 표준 SQL이 제공하는 것은 DELETE 문뿐이다. 하지만 많은 데이터베이스 제품에서는 별도로 'TRUNCATE'라는 명령어를 제공하고 있다. DB2에서는 사용할 수 없다.

TRUNCATE란, '잘라 버리다'는 의미로 구체적으로는 다음과 같이 사용한다.

TRUNCATE <테이블명>;

DELETE와 달리 TRUNCATE는 반드시 테이블의 모든 데이터를 삭제한다. WHERE구로 조건을 지정해서 일부 행만 삭제하는 기능은 없다. 세밀한 제어는 되지 않지만, 대신 DELETE보다 고속으로 데이터를 삭제한다는 장점이 있다. 사실은 DELETE문이라는 것은 DML문 중에서도 시간이 많이 걸리는 처리 중 하나이기 때문에 모든 데이터를 삭제해도 될 때는 TRUNCATE를 사용하는 것이 처리 시간을 단축할 수 있다.
단, Oracle처럼 TRUNCATE를 DML이 아닌 DDL로 정의하고 있는 경우 등 제품에 따라 주의해야 할 점들이 있다. TRUNCATE를 사용할 때는 제품 매뉴얼에 따라서 주의해서 사용하도록 하자. 편리한 도구는 그에 상응하는 단점도 있는 법이다.



p.130
[4-3  UPDATE] 
학습 포인트
* UPDATE 문으로 열을 NULL 클리어할 수 있다.


p.138
NULL로 갱신하려면
UPDATE를 사용해서 열을 NULL로 갱신할 수 있다(이런 갱신을 'NULL 클리어'라고 한다).
이것은 대입식의 우변에 NULL을 직접 쓰면 된다.

e.g.
UPDATE Goods
  SET register_date = NULL
  WHERE goods_id = '0008';

이와 같이 INSERT 문과 동일하게 UPDATE문도 NULL 을 하나의 값으로 취급한다. (단, NULL 클리어가 가능한 것은 NOT NULL 제약이나 주 키 제약이 없는 열에만 해당한다.)


p.139
[ ! ] 4-6
UPDATE 문으로 값을 NULL 클리어할 수도 있다(단, NOT NULL 제약이 없는 열만 해당).


p.139
복수 열 갱신
...
가장 간단한 방법은 리스트 4-18처럼 UPDATE 문을 두개 사용하는 것이다.

```
UPDATE Goods
   SET sell_price = sell_price * 10
 WHERE goods_classify = '주방용품';

UPDATE Goods
   SET buy_price = buy_price / 2
 WHERE goods_classify = '주방용품';
```


UPDATE 문을 두 번이나 실행하는 것은 낭비이자 SQL문 기술량도 늘어난다. 리스트 4-19, 4-20과 같은 두  가지 방법이 있다.

(1)
```
UPDATE Goods
   SET sell_price = sell_price * 10,
       buy_price = buy_price / 2
 WHERE goods_classify = '주방용품';
```

(2)
```
UPDATE Goods
   SET (sell_price, buy_price) = (sell_price * 10, buy_price / 2)
 WHERE goods_classify = '주방용품';
```

물론, SET 구에 2열 뿐만 아니라 3열 이상도 나열할 수 있다. 주의할 것은 열을 쉼표로 구분해서 나열하는 방법(1)은 어떤 DBMS에서도 사용할 수 잇지만, 열을 리스트화하는 방법(2)은 일부 DBMS에서만 가능하다는 것이다. 따라서 방법(1)을 사용하는 것이 확실하다.

[주 4-10]
방법(2)는 PostgreSQL과 DB2에서 사용 가능


p.141
[4-4  TRANSACTION]

학습포인트
* 트랜잭션이란, 세트(한 묶음)로 실행되어야 할 하나 이상의 변경 처리 집합이다. 트랜잭션을 사용하면 데이터베이스의 변경 처리 확정 및 취소 등을 관리할 수 있다.
* 트랜잭션 처리를 종료하는 명령으로 COMMMIT(처리 확정)와 ROLLBACK(처리 취소), 두 가지가 있다.
* DBMS 트랜잭션에는 원자성(Atomicity), 일관성(Consistency), 독립성(Isolation), 지속성(Durability)으로 이루어지는 규칙이 있다. 이들 4가지 속성의 앞 글자만 따서 ACID 특성이라고도 한다.

p.141
RDBMS 세계에서 트랜잭션은 '데이터베이스에서 이루어지는 하나 이상의 갱신 처리를 모아서 부르는 명칭'이다.
테이블 갱신은 앞 절에서 본 것처럼 INSERT, DELETE, UPDATE라는 세 가지 도구를 사용한다. 하지만 갱신은 보통 1회 처리로 끝나지 않고 복수의 처리를 모아서 연속적으로 실행하는 경우가 많다. 트랜잭션이란 이런 복수의 처리를 의미적으로 알기 쉽게 모은 것이라고 생각하면 된다.


p.142
취급 상품 갱신 트랙잭션

[구문 4-6]
1 ) 와이셔츠 판매단가를 1000원 내린다.
UPDATE Goods
  SET sell_price = sell_price - 1000
  WHERE goods_name = '와이셔츠';

2 ) 티셔츠 판매단가를 1000원 올린다.
UPDATE Goods
  SET sell_price = sell_price + 1000
  WHERE goods_name = '티셔츠';

1)과 2) 처리는 반드시 세트로 실행돼야 한다. 1)만 실행하고 2)를 실행하지 않거나, 또는 반대로 처리하면 안된다. 이와같이 '하나의 세트로 실행돼야 할 갱신 집합'은 반드시 트랜잭션으로 모아서 취급할 필요가 있다.


p.142
[ ! ] 4-7
트랜잭션이란, 세트로 실행해야 할 하나이상의 갱신 처리 집합이다.


p.143
트랜잭션을 만들려면
트랜잭션 개시문과 트랜잭션 종료문으로 갱신 DML 문(INSERT/UPDATE/DELETE문)을 감싸는 형식이다.

```
트랜잭션 개시문;

  DML 문(1);
  DML 문(1);
  DML 문(1);
	.
	.
트랜잭션 종료문(COMMIT 또는 ROLLBACK);
```


p.143
이때 주의가 필요한 것은 트랜잭션 개시문이다. 사실은 표준 SQL에서는 트랜잭션 개시문을 확실히 정의하고 있지 않아서 DBMS마다 개별 구문을 사용하고 있다.

* PostgreSQL, SQL Server BEGIN  TRANSACTION 
* MySQL START TRANSACTION 
* Oracle, DB2 없음

p.143
[주 4-11]
트랜잭션 개시문과 달리 트랜잭션 종료문은 COMMIT, ROLLBACK 두 가지 밖에 없으며, 모든 RDBMS에서 동일하다. 예를 들어, 앞 절에서 사용했던 두 가지 UPDATE 1), 2)로 트랜잭션을 만들면 리스트 4-21과 같이 된다.

e.g.
```
BEGIN TRANSACTION;

    -- 와이셔츠 판매단가를 1000원 내린다.
    UPDATE Goods
       SET sell_price = sell_price - 1000
     WHERE goods_name = '와이셔츠;

    -- 티셔츠 판매단가를 1000원 올린다.
    UPDATE Goods
       SET sell_price = sell_price + 1000
     WHERE goods_name = '티셔츠';

COMMIT;
```


p.144
Oracle이나 DB2에서는 개시문 자체가 없다. 특이하다고 생각할 수 있는데, 사실은 표준 SQL에서 트랜잭션 개시를 암묵적으로 실행한다고 정하고 있기 때문이다. 이 때문에 트랜잭션이 개시되는 시점에 관해서는 경험 많은 엔지니어도 의식하지 못하는 경우가 많다.

[주 4-12]
다음과 같이 기록되어 있다. ".. 또한, 트랜잭션이 반드시 암묵적으로 실행되는 것도 주의해야 한다. 'BEGIN TRANSACTION' 같은 명시적인 개시문은 존재하지 않는다"
<표준 SQL 가이드 개정4판>(69페이지)


p.145
ㅁ COMMIT, 처리 확정
COMMIT 이란, 트랜잭션에 의한 변경 내용을 모두 반영한 후에 트랜잭션을 종료하는 명령이다. 파일로 말하자면, 덮어쓰기라고 할 수 있다. 한번 커밋하면 더 이상 트랜잭션 개시 이전으로 돌아갈 수 없기 때문에 커밋하기 전에 정말 필요한 변경인지 잘 생각해 보아야 한다.

만일 잘못된 변경을 내포하고 있는 트랜잭션을 확정해 버리면, 다시 테이블을 만들어서 데이터를 재등록해야 하는 등 매우 복잡한 절차를 밟아야 한다. 최악의 경우 데이터 복원할 수 없는 경우도 있으니 주의가 필요하다.
(특히 DELETE문의 COMMIT은 더 세심한 주의가 필요하다).

p.145
[ ! ] 4-8
트랜잭션 개시 전에는 아무 생각 없이 작업을 할지라도 종료 시에는 정신을 똑바로 차리고 변경 내역을 확정 짓지 않으면 나중에 후회의 눈물을 흘릴 수 있다.


ㅁ ROLLBACK, 처리 취소
ROLLBACK은 트랜잭션에 의해 처리된 변경 내용을 모두 취소하고 트랜잭션을 종료하는 명령이다. 파일로 말하자면, '저장하지 않고 종료'에 해당한다. ROLLBACK하면 데이터 베이스 상대가 트랜잭션 개시전으로 돌아간다(리스트 4-22). 일반적으로, 커밋과 달리 롤백이 데이터 손실로 이어지는 경우는 없다.


p.148
[COLUMN]
트랜잭션은 언제 시작되는가?

앞에서 트랜잭션 개시를 하기 위한 표준 명령은 존재하지 않고 DBMS마다 서로 다른 명령을 사용하고 있다'고 설명했다.

실제로는 대부분 제품에서 트랜잭션 개시 명령을 사용하지 않는다. 즉, 대부분의 경우 데이터베이스에 접속한 시점에 트랜잭션이 암묵적으로 개시되기 때문에 사용자가 명시적으로 트랜잭션을 시작해 줄 필요가 없다.
...
다음 두 가지 패턴을 사용한다.

```
A) 하나의 SQL 문에 하나의 트랜잭션이라는 규칙이 적용된다(자동 커밋 모드)
B) 사용자가 COMMIT 또는 ROLLBACK을 실행하기까지가 하나의 트랜잭션으로 간주된다.
```

일반적인 DBMS에선 둘 다 선택할 수 있다. 자동 커밋을 기본 설정으로 하는 DBMS에는 SQL Server, PostgreSQL, MySQL 등이 있다. 자동 커밋 모드에서는 DML 문 하나마다 트랜잭션 개시문과 종료문이 실행된다.
한편 B) 모드를 기본 설정으로 하고 있는 Oracle은 직접 커밋/롤백하기 전까진 트랜잭션이 종료되지 않는다.

자동 커밋에서 특히 주의해야 할 것이  DELETE 문 실행이다. 자동 커밋이 아니라면 DELETE 문으로 테이블을 삭제했다고 해도 ROLBACK 명령을 사용해서 트랜잭션을 취소하고 데이터를 복구 할 수 있다. 단, 어디가지나 트랜잭션을 명시적으로 개시하고 있든가, 또는 자동 커밋 모드를 꺼놓은 상태일 때만 가능하다. 잘못해서 자동 커밋 모드가 켜져있는 상태에서 DELETE 문을 실행하면 롤백으로 복원할 수 없다.



[주 4-13]
예를 들어, PostgreSQL 매뉴얼에는 이렇게 기록되어 있다. "PostgreSQL은 실제 모든 SQL문을 트랜잭션 내에서 실행하도록 되어 있다. BEGIN을 실행하지 않아도 각각의 명령문이 암묵적으로 BEGIN이 되어 있다고 간주하고 (성공하면) COMMIT으로 종료된다."
(<PostgreSQL SQL 8.3.4>의 3.4 트랜잭션)



p.148
ACID 특성

ㅁ 원자성 (Atomicity)
트랜잭션이 끝난 시점에 모든 갱신 처리가 실행된 상태 또는 모두 실행되지 않은 상태로 종료되는 것을 보증하는 성질이다. All or Nothing 이라고도 한다.
...
왜 이 원자성이 중요한가 하면, 트랜잭션이 어중간하게 종료되는 경우를 생각하면 이해하기 쉽다.


ㅁ 일관성 (Consistency)
트랜잭션에 포함되는 처리는 데이터베이스에 미리 설정된 제약, 예를 들어 주키 제약이나 NOT NULL 제약을 지켜야 한다는 성질이다. 예를 들어, 앞에서도 배웠듯이 NOT NULL 제약이 있는 열을 NULL로 갱신하거나, 주 키 제약 위반 레코드를 삽입하는 SQL 문은 에러 처리된다. 이것을 트랜잭션 관점에서 표현하면 SQL이 '롤백되었다'고 할 수 있다. 즉, SQL이 한 문장 단위로 취소되어서 실행되지 않았다는 것과 동일한 의미가 된다.
참고로, 일관성은 '정합성'이라고도 부른다.


ㅁ 독립성 (Isolation)
트랜잭션 상호 간에 서로 간섭하지 않음을 보증하는 성질이다. 이 성질에 의해서 트랜잭션 상호 간에 내포 관계는 성립하지 않는다. 또한, 어떤 트랜잭션에 의한 변경은 트랜잭션 종료 시까지는 다른 트랜잭션으로부터 은폐된다. 따라서 어떤 트랜잭션이 테이블에 레코드를 추가했다고 해도 커밋을 하기 전까지는 다른 트랜잭션이 추가한 레코드를 인식할 수 없다.


ㅁ 지속성 (Durability)
이것은 영속성이라고도 하는데, 트랜잭션이 (커밋이든 롤백이든) 종료되면 해당 시점의 데이터 상태가 저장되는 것을 보증하는 성질이다. 시스템에 장애가 발생해서 데이터가 망가진 경우라도 데이터베이스는 어떠한 방법으로든 복구 수단을 제공해야 한다.
만일 지속성이 없으면 무사히 트랜잭션을 커밋해서 종료했다고 해도 시스템에 장애가 발생해서 데이터가 모두 사라져 버릴 수 있으며, 이 경우 처음부터 모든 처리를 다시 해야하는 상황이 발생할 수 있다.

이 지속성을 보증하는 방법은 구현 방법에 따라 다른데, 가장 일반적인 방법은 트랜잭션 실행 기록을 디스크 등에 기록해 두었다가(이와 같은 실행 기록을 '로그'라고 한다.) 장애가 발생한 경우에 이 로그를 사용해서 장애 이전 상태로 복원하는 것이다.



